{"version":3,"sources":["../src/index.ts","../src/core/Queue.ts","../src/decorators/singleton.ts"],"sourcesContent":["export { QueueMeta } from \"./core/Queue\";\nexport { singleton, kInstance } from \"./decorators/singleton\";\nexport * from \"./typings\";\n","import { QueueType } from \"../typings\";\n\nexport class QueueMeta<T = unknown> {\n    private internalQueue: T[] = [];\n    public method: QueueType;\n    public constructor(method: QueueType = \"FIFO\") {\n        if (![\"FIFO\", \"LIFO\"].includes(method)) throw new TypeError(`Expected queue method to be \"FIFO\" or \"LIFO\", got \"${method}\"`);\n        this.method = method;\n    }\n\n    public set(items: T[]) {\n        this.internalQueue = items;\n        return this;\n    }\n\n    public has(item: T) {\n        return this.internalQueue.some((x) => x === item);\n    }\n\n    public get raw() {\n        return this.internalQueue;\n    }\n\n    public insert(item: T) {\n        this.internalQueue.push(item);\n        return item;\n    }\n\n    public remove(item: T) {\n        if (this.internalQueue.indexOf(item) < 0) return false;\n        this.internalQueue.splice(this.internalQueue.indexOf(item), 1);\n        return item;\n    }\n\n    public shuffle(excludeFirst = true) {\n        const shuffleThis = () => {\n            for (let i = this.internalQueue.length - 1; i > 0; i--) {\n                const j = Math.floor(Math.random() * (i + 1));\n                [this.internalQueue[i], this.internalQueue[j]] = [this.internalQueue[j], this.internalQueue[i]];\n            }\n        };\n\n        if (!excludeFirst) return shuffleThis();\n\n        const current = this.shift();\n        shuffleThis();\n        this.unshift(current.item, current.index);\n    }\n\n    public clear() {\n        this.internalQueue = [];\n    }\n\n    public shift() {\n        const itemToRemove = this.first();\n        const idx = this.internalQueue.indexOf(itemToRemove);\n        this.internalQueue.splice(idx, 1);\n        return { item: itemToRemove, index: idx };\n    }\n\n    public unshift(item: T, idx = 0) {\n        if (idx < 0) idx = 0;\n        if (idx > this.internalQueue.length) idx = this.internalQueue.length;\n        this.internalQueue.splice(idx, 0, item);\n        return item;\n    }\n\n    public first() {\n        if (this.method === \"FIFO\") return this.internalQueue[0];\n        return this.internalQueue[this.internalQueue.length - 1];\n    }\n\n    public last() {\n        if (this.method === \"FIFO\") return this.internalQueue[this.internalQueue.length - 1];\n        return this.internalQueue[0];\n    }\n\n    public random() {\n        return this.internalQueue[Math.floor(Math.random() * this.internalQueue.length)];\n    }\n\n    public getInternal() {\n        return this.internalQueue;\n    }\n\n    public copy() {\n        return this.clone();\n    }\n\n    public clone() {\n        return new QueueMeta<T>(this.method).set(this.internalQueue.slice());\n    }\n\n    public get count() {\n        return this.internalQueue.length;\n    }\n\n    public *iterate() {\n        yield* this.toArray();\n    }\n\n    public *[Symbol.iterator]() {\n        yield* this.toArray();\n    }\n\n    public toJSON() {\n        return this.toArray();\n    }\n\n    public toArray() {\n        return this.method === \"FIFO\" ? this.internalQueue.slice() : this.internalQueue.slice().reverse();\n    }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport const kInstance = Symbol(\"instance\");\n\ntype SingletonClass<T extends new (...args: any[]) => any> = T & {\n    [kInstance]: T extends new (...args: any[]) => infer I ? I : never;\n};\n\nexport default function singleton() {\n    return <T extends new (...args: any[] | undefined) => any>(targetClass: T) => {\n        return new Proxy(targetClass, {\n            construct: (target: SingletonClass<T>, argumentsList, newTarget) => {\n                if (target.prototype !== newTarget.prototype) return Reflect.construct(target, argumentsList, newTarget);\n                if (!target[kInstance]) target[kInstance] = new target(...argumentsList);\n                return target[kInstance];\n            }\n        });\n    };\n}\n\nexport { singleton };\n"],"mappings":"8gBAAA,gECEO,WAA6B,CAGzB,YAAY,EAAoB,OAAQ,CAFvC,mBAAqB,GAGzB,GAAI,CAAC,CAAC,OAAQ,QAAQ,SAAS,GAAS,KAAM,IAAI,WAAU,sDAAsD,MAClH,KAAK,OAAS,EAGX,IAAI,EAAY,CACnB,YAAK,cAAgB,EACd,KAGJ,IAAI,EAAS,CAChB,MAAO,MAAK,cAAc,KAAK,AAAC,GAAM,IAAM,MAGrC,MAAM,CACb,MAAO,MAAK,cAGT,OAAO,EAAS,CACnB,YAAK,cAAc,KAAK,GACjB,EAGJ,OAAO,EAAS,CACnB,MAAI,MAAK,cAAc,QAAQ,GAAQ,EAAU,GACjD,MAAK,cAAc,OAAO,KAAK,cAAc,QAAQ,GAAO,GACrD,GAGJ,QAAQ,EAAe,GAAM,CAChC,GAAM,GAAc,IAAM,CACtB,OAAS,GAAI,KAAK,cAAc,OAAS,EAAG,EAAI,EAAG,IAAK,CACpD,GAAM,GAAI,KAAK,MAAM,KAAK,SAAY,GAAI,IAC1C,CAAC,KAAK,cAAc,GAAI,KAAK,cAAc,IAAM,CAAC,KAAK,cAAc,GAAI,KAAK,cAAc,MAIpG,GAAI,CAAC,EAAc,MAAO,KAE1B,GAAM,GAAU,KAAK,QACrB,IACA,KAAK,QAAQ,EAAQ,KAAM,EAAQ,OAGhC,OAAQ,CACX,KAAK,cAAgB,GAGlB,OAAQ,CACX,GAAM,GAAe,KAAK,QACpB,EAAM,KAAK,cAAc,QAAQ,GACvC,YAAK,cAAc,OAAO,EAAK,GACxB,CAAE,KAAM,EAAc,MAAO,GAGjC,QAAQ,EAAS,EAAM,EAAG,CAC7B,MAAI,GAAM,GAAG,GAAM,GACf,EAAM,KAAK,cAAc,QAAQ,GAAM,KAAK,cAAc,QAC9D,KAAK,cAAc,OAAO,EAAK,EAAG,GAC3B,EAGJ,OAAQ,CACX,MAAI,MAAK,SAAW,OAAe,KAAK,cAAc,GAC/C,KAAK,cAAc,KAAK,cAAc,OAAS,GAGnD,MAAO,CACV,MAAI,MAAK,SAAW,OAAe,KAAK,cAAc,KAAK,cAAc,OAAS,GAC3E,KAAK,cAAc,GAGvB,QAAS,CACZ,MAAO,MAAK,cAAc,KAAK,MAAM,KAAK,SAAW,KAAK,cAAc,SAGrE,aAAc,CACjB,MAAO,MAAK,cAGT,MAAO,CACV,MAAO,MAAK,QAGT,OAAQ,CACX,MAAO,IAAI,GAAa,KAAK,QAAQ,IAAI,KAAK,cAAc,YAGrD,QAAQ,CACf,MAAO,MAAK,cAAc,QAGtB,SAAU,CACd,MAAO,KAAK,YAGP,OAAO,WAAY,CACxB,MAAO,KAAK,UAGT,QAAS,CACZ,MAAO,MAAK,UAGT,SAAU,CACb,MAAO,MAAK,SAAW,OAAS,KAAK,cAAc,QAAU,KAAK,cAAc,QAAQ,YC5GzF,GAAM,GAAY,OAAO,YAMjB,YAAqB,CAChC,MAAO,AAAoD,IAChD,GAAI,OAAM,EAAa,CAC1B,UAAW,CAAC,EAA2B,EAAe,IAC9C,EAAO,YAAc,EAAU,UAAkB,QAAQ,UAAU,EAAQ,EAAe,GACzF,GAAO,IAAY,GAAO,GAAa,GAAI,GAAO,GAAG,IACnD,EAAO","names":[]}